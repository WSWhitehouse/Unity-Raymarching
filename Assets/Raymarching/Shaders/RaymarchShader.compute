#pragma kernel CSMain

#include "UnityCG.cginc"
#include "DistanceFunctions.cginc"
#include "RaymarchInfoStructs.cginc"
#include "Ray.cginc"

Texture2D<float4> _Source;
RWTexture2D<float4> _Destination;

// Camera
Texture2D<float4> _DepthTexture;
float4x4 _CamInverseProjection;
float4x4 _CamToWorld;
float _CamNearClipPlane;

// Raymarching
float _RenderDistance;
float _HitResolution;
float _Relaxation;
int _MaxIterations;

// Lighting & Shadows
float3 _AmbientColour;
#pragma multi_compile NO_SHADOWS HARD_SHADOWS SOFT_SHADOWS

#if NO_SHADOWS
#else
float _ShadowIntensity;
int _ShadowSteps;
float2 _ShadowDistance;
#endif

#if SOFT_SHADOWS
float _ShadowPenumbra;
#endif

// Raymarch Object Info
RWStructuredBuffer<RaymarchObjectInfo> _ObjectInfo;
int _ObjectInfoCount;

// Raymarch Light Info
RWStructuredBuffer<RaymarchLightInfo> _LightInfo;
int _LightInfoCount;

float PerformSDF(float3 origin, RaymarchObjectInfo object)
{
    // Position
    object.Position = origin - object.Position;

    // Rotation
    object.Position.xz = mul(object.Position.xz,
                             float2x2(cos(object.Rotation.y), sin(object.Rotation.y),
                                      -sin(object.Rotation.y), cos(object.Rotation.y)));
    object.Position.yz = mul(object.Position.yz,
                             float2x2(cos(object.Rotation.x), -sin(object.Rotation.x),
                                      sin(object.Rotation.x), cos(object.Rotation.x)));
    object.Position.xy = mul(object.Position.xy,
                             float2x2(cos(object.Rotation.z), -sin(object.Rotation.z),
                                      sin(object.Rotation.z), cos(object.Rotation.z)));

    // Scale
    object.Scale *= 0.5;
    // object.Roundness *= 0.5;
    object.Scale -= object.Roundness;

    float dist = _RenderDistance;

    switch (object.SdfShape)
    {
    case 0:
        {
            dist = sdf_sphere(object);
            break;
        }
    case 1:
        {
            dist = sdf_box(object);
            break;
        }
    default: return dist;
    }

    return (abs(dist - object.Roundness + object.WallThickness) - object.WallThickness) / object.MarchingStepAmount;
}

float4 PerformOperation(float globalDistance, float3 globalColour, float objectDistance, RaymarchObjectInfo object)
{
    float distance = globalDistance;
    float3 colour = globalColour;

    // https://www.iquilezles.org/www/articles/smin/smin.htm

    switch (object.Operation)
    {
    case 1: // blend
        {
            const float h = clamp(0.5 + 0.5 * (objectDistance - distance) / object.OperationMod, 0.0, 1.0);
            distance = lerp(objectDistance, distance, h) - object.OperationMod * h * (1.0 - h);
            colour = lerp(object.Colour, colour, h);
            break;
        }
    case 2: // cut
        {
            if (object.OperationSmooth)
            {
                const float h = clamp(0.5 - 0.5 * (distance + objectDistance) / object.OperationMod, 0.0, 1.0);
                distance = lerp(distance, -objectDistance, h) + object.OperationMod * h * (1.0 - h);
                break;
            }

            if (-objectDistance > distance)
            {
                distance = -objectDistance;
            }
            break;
        }
    case 3: // mask
        {
            if (object.OperationSmooth)
            {
                const float h = clamp(0.5 - 0.5 * (distance - objectDistance) / object.OperationMod, 0.0, 1.0);
                distance = lerp(distance, objectDistance, h) + object.OperationMod * h * (1.0 - h);
                break;
            }

            if (objectDistance > distance)
            {
                distance = objectDistance;
            }
            break;
        }
    default:
        {
            if (objectDistance < distance)
            {
                distance = objectDistance;
                colour = object.Colour;
            }
            break;
        }
    }

    return float4(colour.xyz, distance);
}

float4 GetDistanceFromObjects(float3 origin)
{
    float distance = _RenderDistance;
    float3 colour = float3(1, 1, 1);

    for (int i = 0; i < _ObjectInfoCount; i++)
    {
        const float objectDistance = PerformSDF(origin, _ObjectInfo[i]);
        const float4 operation = PerformOperation(distance, colour, objectDistance, _ObjectInfo[i]);

        distance = operation.w;
        colour = operation.xyz;
    }

    return float4(colour.xyz, distance);
}

#if HARD_SHADOWS
float HardShadow(float3 pos, float3 dir)
{
    float t = _ShadowDistance.x;

    for (int i = 0; i < _ShadowSteps; i++)
    {
        if (t >= _ShadowDistance.y) break;

        const float h = GetDistanceFromObjects(pos + dir * t);
        if (h < _HitResolution)
        {
            return 0.0;
        }
        t += h;
    }
    return 1.0;
}
#endif

#if SOFT_SHADOWS
float SoftShadow(float3 pos, float3 dir, float k)
{
    float res = 1.0;
    float t = _ShadowDistance.x;
    for (int i = 0; i < _ShadowSteps; ++i)
    {
        if (t >= _ShadowDistance.y) break;

        const float h = GetDistanceFromObjects(pos + dir * t);
        if (h < _HitResolution)
        {
            return 0.0;
        }

        res = min(res, k * h / t);
        t += h;
    }
    return res;
}
#endif

float3 GetLight(float3 pos, float3 normal, float3 colour)
{
    float3 light = float3(0, 0, 0);

    for (int i = 0; i < _LightInfoCount; i++)
    {
        switch (_LightInfo[i].LightType)
        {
        case 0: // directional
            {
                const float diffuse = max(0.0, dot(-normal, _LightInfo[i].Direction)) * _LightInfo[i].Intensity;
                light += diffuse * (_LightInfo[i].Colour * colour);

                #if HARD_SHADOWS
                const float shadow = max(0.0, pow(HardShadow(pos, -_LightInfo[i].Direction) * 0.5 + 0.5, _ShadowIntensity));
                light *= shadow;
                #endif

                #if SOFT_SHADOWS
                const float shadow = max(0.0, pow(SoftShadow(pos, -_LightInfo[i].Direction, _ShadowPenumbra) * 0.5 + 0.5, _ShadowIntensity));
                light *= shadow;
                #endif

                break;
            }
        case 1: // point
        default:
            {
                //http://forum.unity3d.com/threads/light-attentuation-equation.16006/
                const float3 toLight = pos - _LightInfo[i].Position;
                const float range = clamp(length(toLight) / _LightInfo[i].Range, 0., 1.);
                const float attenuation = 1.0 / (1.0 + 256.0 * range * range);
                const float diffuse = max(0.0, dot(-normal, normalize(toLight.xyz))) *
                    _LightInfo[i].Intensity * attenuation;
                light += diffuse * (_LightInfo[i].Colour * colour);
                break;
            }
        }
    }

    return light;
}

float3 GetObjectNormal(float3 pos)
{
    const float2 offset = float2(0.01f, 0.0f);
    const float3 normal = float3(
        GetDistanceFromObjects(pos + offset.xyy).w - GetDistanceFromObjects(pos - offset.xyy).w,
        GetDistanceFromObjects(pos + offset.yxy).w - GetDistanceFromObjects(pos - offset.yxy).w,
        GetDistanceFromObjects(pos + offset.yyx).w - GetDistanceFromObjects(pos - offset.yyx).w
    );

    return normalize(normal);
}

float3 CalculateLighting(Ray ray, float3 colour, float distance)
{
    // Object Shading
    const float3 pos = ray.Origin + ray.Direction * distance;
    const float3 normal = GetObjectNormal(pos);
    const float3 light = GetLight(pos, normal, colour);

    // Adding Light
    float3 combinedColour = colour * _AmbientColour;
    combinedColour += light;

    return combinedColour;
}

fixed4 RaymarchSimple(Ray ray, float depth)
{
    float distanceTraveled = _CamNearClipPlane;

    [loop]
    for (int i = 0; i < _MaxIterations; i++)
    {
        if (distanceTraveled > _RenderDistance || distanceTraveled >= depth)
        {
            // Environment
            return fixed4(ray.Direction, 0);
        }

        const float3 pos = ray.Origin + ray.Direction * distanceTraveled;
        const float4 combined = GetDistanceFromObjects(pos);
        const float3 colour = combined.xyz;
        const float distance = combined.w;

        if (distance < _HitResolution) // Hit something
        {
            return fixed4(CalculateLighting(ray, colour, distance), 1);
        }

        distanceTraveled += distance;
    }

    return fixed4(ray.Direction, 0);
}

fixed4 Raymarch(Ray ray, float depth)
{
    float relaxOmega = _Relaxation;
    float distanceTraveled = _CamNearClipPlane;
    float candidateError = _RenderDistance;
    float candidateDistanceTraveled = distanceTraveled;
    float3 candidateColour = float3(0, 0, 0);
    float prevRadius = 0;
    float stepLength = 0;

    const float funcSign = GetDistanceFromObjects(ray.Origin).w < 0 ? -1 : +1;

    [loop]
    for (int i = 0; i < _MaxIterations; i++)
    {
        const float3 pos = ray.Origin + ray.Direction * distanceTraveled;
        const float4 combined = GetDistanceFromObjects(pos);
        const float3 colour = combined.xyz;
        const float distance = combined.w;

        const float signedRadius = funcSign * distance;
        const float radius = abs(signedRadius);

        const bool sorFail = relaxOmega > 1 && (radius + prevRadius) < stepLength;

        [branch]
        if (sorFail)
        {
            stepLength -= relaxOmega * stepLength;
            relaxOmega = 1;
        }
        else
        {
            stepLength = signedRadius * relaxOmega;
        }

        prevRadius = radius;

        [branch]
        if (sorFail)
        {
            distanceTraveled += stepLength;
            continue;
        }

        if (distanceTraveled > _RenderDistance || distanceTraveled >= depth) // Environment
        {
            return fixed4(ray.Direction, 0);
        }

        const float error = radius / distanceTraveled;

        if (error < candidateError)
        {
            candidateDistanceTraveled = distanceTraveled;
            candidateColour = colour;
            candidateError = error;

            if (error < _HitResolution) break; // Hit Something
        }

        distanceTraveled += stepLength;
    }

    return fixed4(CalculateLighting(ray, candidateColour, candidateDistanceTraveled), 1);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    const uint2 xy = id.xy;

    uint width, height;
    _Destination.GetDimensions(width, height);
    const float2 uv = xy / float2(width, height) * 2 - 1;

    Ray ray = CreateCameraRay(uv, _CamToWorld, _CamInverseProjection);
    float depth = LinearEyeDepth(_DepthTexture[xy].r);
    depth *= length(ray.Direction);

    ray.Direction = normalize(ray.Direction);

    fixed4 result = Raymarch(ray, depth);
    _Destination[xy] = fixed4(_Source[xy] * (1.0 - result.w) + result.xyz * result.w, 1.0);
}
