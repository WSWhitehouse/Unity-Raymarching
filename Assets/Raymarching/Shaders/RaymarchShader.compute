#pragma kernel CSMain

#include "UnityCG.cginc"
#include "DistanceFunctions.cginc"
#include "RaymarchObjectInfo.cginc"
#include "Ray.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> _Source;
RWTexture2D<float4> _Destination;

// Camera
Texture2D<float4> _CamDepthTexture;
float4x4 _CamInverseProjection;
float4x4 _CamToWorld;
float _RenderDistance;

// Raymarching
int _MaxIterations;
float _HitResolution;

// Lighting
float3 _LightDirection;

// Raymarch Object Info
StructuredBuffer<RaymarchObjectInfo> _ObjectInfo;
int _ObjectInfoCount;

float PerformSDF(float3 origin, RaymarchObjectInfo object)
{
    // Position
    object.Position = origin - object.Position;

    // Rotation
    object.Position.xz = mul(object.Position.xz,
                             float2x2(cos(object.Rotation.y), sin(object.Rotation.y),
                                      -sin(object.Rotation.y), cos(object.Rotation.y)));
    object.Position.yz = mul(object.Position.yz,
                             float2x2(cos(object.Rotation.x), -sin(object.Rotation.x),
                                      sin(object.Rotation.x), cos(object.Rotation.x)));
    object.Position.xy = mul(object.Position.xy,
                             float2x2(cos(object.Rotation.z), -sin(object.Rotation.z),
                                      sin(object.Rotation.z), cos(object.Rotation.z)));

    // Scale
    object.Scale *= 0.5;
    // object.Roundness *= 0.5;
    object.Scale -= object.Roundness;

    float dist = _RenderDistance;

    switch (object.SdfShape)
    {
    case 0:
        {
            dist = sdf_sphere(object);
            break;
        }
    case 1:
        {
            dist = sdf_box(object);
            break;
        }
    default: return dist;
    }

    return (abs(dist - object.Roundness + object.WallThickness) - object.WallThickness) / object.MarchingStepAmount;
}

float4 PerformOperation(float globalDistance, float3 globalColour, float objectDistance, RaymarchObjectInfo object)
{
    float distance = globalDistance;
    float3 colour = globalColour;

    // https://www.iquilezles.org/www/articles/smin/smin.htm

    switch (object.Operation)
    {
    case 1: // blend
        {
            const float h = clamp(0.5 + 0.5 * (objectDistance - distance) / object.OperationMod, 0.0, 1.0);
            distance = lerp(objectDistance, distance, h) - object.OperationMod * h * (1.0 - h);
            colour = lerp(object.Colour.xyz, colour, h);
            break;
        }
    case 2: // cut
        {
            if (object.OperationSmooth)
            {
                const float h = clamp(0.5 - 0.5 * (distance + objectDistance) / object.OperationMod, 0.0, 1.0);
                distance = lerp(distance, -objectDistance, h) + object.OperationMod * h * (1.0 - h);
                break;
            }

            if (-objectDistance > distance)
            {
                distance = -objectDistance;
            }
            break;
        }
    case 3: // mask
        {
            if (object.OperationSmooth)
            {
                const float h = clamp(0.5 - 0.5 * (distance - objectDistance) / object.OperationMod, 0.0, 1.0);
                distance = lerp(distance, objectDistance, h) + object.OperationMod * h * (1.0 - h);
                break;
            }

            if (objectDistance > distance)
            {
                distance = objectDistance;
            }
            break;
        }
    default:
        {
            if (objectDistance < distance)
            {
                distance = objectDistance;
                colour = object.Colour.xyz;
            }
            break;
        }
    }

    return float4(colour.xyz, distance);
}

float4 distanceField(float3 origin)
{
    float distance = _RenderDistance;
    float3 colour = float3(1, 1, 1);

    for (int i = 0; i < _ObjectInfoCount; i++)
    {
        const float objectDistance = PerformSDF(origin, _ObjectInfo[i]);
        const float4 operation = PerformOperation(distance, colour, objectDistance, _ObjectInfo[i]);

        distance = operation.w;
        colour = operation.xyz;
    }

    return float4(colour.xyz, distance);
}

float3 getNormal(float3 pos)
{
    const float2 offset = float2(0.01f, 0.0f);
    const float3 normal = float3(
        distanceField(pos + offset.xyy).w - distanceField(pos - offset.xyy).w,
        distanceField(pos + offset.yxy).w - distanceField(pos - offset.yxy).w,
        distanceField(pos + offset.yyx).w - distanceField(pos - offset.yyx).w
    );

    return normalize(normal);
}

fixed4 raymarching(Ray ray, float depth)
{
    fixed4 result = fixed4(1, 1, 1, 1);
    
    float distanceTraveled = 0;

    for (int i = 0; i < _MaxIterations; i++)
    {
        if (distanceTraveled > _RenderDistance || distanceTraveled >= depth)
        {
            // Environment
            result = fixed4(ray.Direction, 0);
            break;
        }

        const float3 pos = ray.Origin + ray.Direction * distanceTraveled;
        // Check for hit in distance field
        const float4 combined = distanceField(pos);
        const float3 colour = combined.xyz;
        const float distance = combined.w;

        if (distance < _HitResolution) // Hit something
        {
            // Object Shading
            const float3 normal = getNormal(pos);
            const float light = dot(-_LightDirection, normal);

            result = fixed4(colour * light, 1);
            break;
        }

        distanceTraveled += distance;
    }

    return result;
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _Destination.GetDimensions(width, height);
    const float2 uv = id.xy / float2(width, height) * 2 - 1;

    Ray ray = CreateCameraRay(uv, _CamToWorld, _CamInverseProjection);
    float depth = LinearEyeDepth(_CamDepthTexture[id.xy].r);
    depth *= length(ray.Direction);

    ray.Direction = normalize(ray.Direction);

    fixed4 result = raymarching(ray, depth);
    _Destination[id.xy] = fixed4(_Source[id.xy] * (1.0 - result.w) + result.xyz * result.w, 1.0);
}
