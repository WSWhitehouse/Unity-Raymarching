//---------------------------------------------------------------------
//    This code was generated by a tool.                               
//                                                                     
//    Changes to this file may cause incorrect behavior and will be    
//    lost if the code is regenerated.                                 
//                                                                     
//    Time Generated: 10/11/2021 10:47:08
//---------------------------------------------------------------------

Shader "Raymarch/RayMarching_RaymarchShader"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        HLSLINCLUDE
        // Unity Includes
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"

        // Includes
        #include "Assets/Raymarching/Shaders/Generated/DistanceFunctions.hlsl"
        #include "Assets/Raymarching/Shaders/Generated/MaterialFunctions.hlsl"
        #include "Assets/Raymarching/Shaders/Ray.hlsl"

        #pragma vertex vert
        #pragma fragment frag
        #pragma target 3.0

        struct appdata
        {
            float4 vertex : POSITION;
            float2 uv : TEXCOORD0;
        };

        struct v2f
        {
            float2 uv : TEXCOORD0;
            float4 vertex : SV_POSITION;
        };

        // Camera
        uniform float4x4 _CamToWorldMatrix;

        // Raymarching
        uniform float _RenderDistance;
        uniform float _HitResolution;
        uniform float _Relaxation;
        uniform int _MaxIterations;

        // Lighting & Shadows
        uniform float3 _AmbientColour;

        // Raymarch Variables

uniform float3 _Position88a5b9efeaaf47789d26eb58407396af;
uniform float3 _Rotation88a5b9efeaaf47789d26eb58407396af;
uniform float3 _Scale88a5b9efeaaf47789d26eb58407396af;
uniform float4 _Colour88a5b9efeaaf47789d26eb58407396af;

uniform float3 _Position3c91d5f52d5b42c39cb8d5f9021fa043;
uniform float3 _Rotation3c91d5f52d5b42c39cb8d5f9021fa043;
uniform float3 _Scale3c91d5f52d5b42c39cb8d5f9021fa043;
uniform float4 _Colour3c91d5f52d5b42c39cb8d5f9021fa043;

uniform float3 _Positionf10fc8cd374c4bbbbd965d4d0f46fb71;
uniform float3 _Rotationf10fc8cd374c4bbbbd965d4d0f46fb71;
uniform float3 _Scalef10fc8cd374c4bbbbd965d4d0f46fb71;
uniform float4 _Colourf10fc8cd374c4bbbbd965d4d0f46fb71;

uniform float3 _Position7031e04a7ad344669638bbee6d28c5e0;
uniform float3 _Rotation7031e04a7ad344669638bbee6d28c5e0;
uniform float3 _Scale7031e04a7ad344669638bbee6d28c5e0;
uniform float4 _Colour7031e04a7ad344669638bbee6d28c5e0;

uniform float3 _Position57c95a0f6ffa4354bf7f8f17f47c3610;
uniform float3 _Rotation57c95a0f6ffa4354bf7f8f17f47c3610;
uniform float3 _Scale57c95a0f6ffa4354bf7f8f17f47c3610;
uniform float4 _Colour57c95a0f6ffa4354bf7f8f17f47c3610;



        float4 GetDistanceFromObjects(float3 origin)
        {
            float resultDistance = _RenderDistance;
            float3 resultColour = float3(1, 1, 1);

            
float3 position88a5b9efeaaf47789d26eb58407396af = origin - _Position88a5b9efeaaf47789d26eb58407396af;

position88a5b9efeaaf47789d26eb58407396af.xz = mul(position88a5b9efeaaf47789d26eb58407396af.xz, float2x2(cos(_Rotation88a5b9efeaaf47789d26eb58407396af.y), sin(_Rotation88a5b9efeaaf47789d26eb58407396af.y), -sin(_Rotation88a5b9efeaaf47789d26eb58407396af.y), cos(_Rotation88a5b9efeaaf47789d26eb58407396af.y)));
position88a5b9efeaaf47789d26eb58407396af.yz = mul(position88a5b9efeaaf47789d26eb58407396af.yz, float2x2(cos(_Rotation88a5b9efeaaf47789d26eb58407396af.x), -sin(_Rotation88a5b9efeaaf47789d26eb58407396af.x), sin(_Rotation88a5b9efeaaf47789d26eb58407396af.x), cos(_Rotation88a5b9efeaaf47789d26eb58407396af.x)));
position88a5b9efeaaf47789d26eb58407396af.xy = mul(position88a5b9efeaaf47789d26eb58407396af.xy, float2x2(cos(_Rotation88a5b9efeaaf47789d26eb58407396af.z), -sin(_Rotation88a5b9efeaaf47789d26eb58407396af.z), sin(_Rotation88a5b9efeaaf47789d26eb58407396af.z), cos(_Rotation88a5b9efeaaf47789d26eb58407396af.z)));

float distance88a5b9efeaaf47789d26eb58407396af = SDF_Cube_05845aac9d55425c8e1f8d191d017e1e(position88a5b9efeaaf47789d26eb58407396af, _Scale88a5b9efeaaf47789d26eb58407396af);

if (distance88a5b9efeaaf47789d26eb58407396af < resultDistance)
{
resultDistance = distance88a5b9efeaaf47789d26eb58407396af;
resultColour = _Colour88a5b9efeaaf47789d26eb58407396af.xyz;
}

float3 position3c91d5f52d5b42c39cb8d5f9021fa043 = origin - _Position3c91d5f52d5b42c39cb8d5f9021fa043;

position3c91d5f52d5b42c39cb8d5f9021fa043.xz = mul(position3c91d5f52d5b42c39cb8d5f9021fa043.xz, float2x2(cos(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.y), sin(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.y), -sin(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.y), cos(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.y)));
position3c91d5f52d5b42c39cb8d5f9021fa043.yz = mul(position3c91d5f52d5b42c39cb8d5f9021fa043.yz, float2x2(cos(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.x), -sin(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.x), sin(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.x), cos(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.x)));
position3c91d5f52d5b42c39cb8d5f9021fa043.xy = mul(position3c91d5f52d5b42c39cb8d5f9021fa043.xy, float2x2(cos(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.z), -sin(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.z), sin(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.z), cos(_Rotation3c91d5f52d5b42c39cb8d5f9021fa043.z)));

float distance3c91d5f52d5b42c39cb8d5f9021fa043 = SDF_Sphere_5a5c930dec9347e2970ec043d92e6116(position3c91d5f52d5b42c39cb8d5f9021fa043, _Scale3c91d5f52d5b42c39cb8d5f9021fa043);

if (distance3c91d5f52d5b42c39cb8d5f9021fa043 < resultDistance)
{
resultDistance = distance3c91d5f52d5b42c39cb8d5f9021fa043;
resultColour = _Colour3c91d5f52d5b42c39cb8d5f9021fa043.xyz;
}

float3 positionf10fc8cd374c4bbbbd965d4d0f46fb71 = origin - _Positionf10fc8cd374c4bbbbd965d4d0f46fb71;

positionf10fc8cd374c4bbbbd965d4d0f46fb71.xz = mul(positionf10fc8cd374c4bbbbd965d4d0f46fb71.xz, float2x2(cos(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.y), sin(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.y), -sin(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.y), cos(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.y)));
positionf10fc8cd374c4bbbbd965d4d0f46fb71.yz = mul(positionf10fc8cd374c4bbbbd965d4d0f46fb71.yz, float2x2(cos(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.x), -sin(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.x), sin(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.x), cos(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.x)));
positionf10fc8cd374c4bbbbd965d4d0f46fb71.xy = mul(positionf10fc8cd374c4bbbbd965d4d0f46fb71.xy, float2x2(cos(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.z), -sin(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.z), sin(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.z), cos(_Rotationf10fc8cd374c4bbbbd965d4d0f46fb71.z)));

float distancef10fc8cd374c4bbbbd965d4d0f46fb71 = SDF_Sphere_5a5c930dec9347e2970ec043d92e6116(positionf10fc8cd374c4bbbbd965d4d0f46fb71, _Scalef10fc8cd374c4bbbbd965d4d0f46fb71);

if (distancef10fc8cd374c4bbbbd965d4d0f46fb71 < resultDistance)
{
resultDistance = distancef10fc8cd374c4bbbbd965d4d0f46fb71;
resultColour = _Colourf10fc8cd374c4bbbbd965d4d0f46fb71.xyz;
}

float3 position7031e04a7ad344669638bbee6d28c5e0 = origin - _Position7031e04a7ad344669638bbee6d28c5e0;

position7031e04a7ad344669638bbee6d28c5e0.xz = mul(position7031e04a7ad344669638bbee6d28c5e0.xz, float2x2(cos(_Rotation7031e04a7ad344669638bbee6d28c5e0.y), sin(_Rotation7031e04a7ad344669638bbee6d28c5e0.y), -sin(_Rotation7031e04a7ad344669638bbee6d28c5e0.y), cos(_Rotation7031e04a7ad344669638bbee6d28c5e0.y)));
position7031e04a7ad344669638bbee6d28c5e0.yz = mul(position7031e04a7ad344669638bbee6d28c5e0.yz, float2x2(cos(_Rotation7031e04a7ad344669638bbee6d28c5e0.x), -sin(_Rotation7031e04a7ad344669638bbee6d28c5e0.x), sin(_Rotation7031e04a7ad344669638bbee6d28c5e0.x), cos(_Rotation7031e04a7ad344669638bbee6d28c5e0.x)));
position7031e04a7ad344669638bbee6d28c5e0.xy = mul(position7031e04a7ad344669638bbee6d28c5e0.xy, float2x2(cos(_Rotation7031e04a7ad344669638bbee6d28c5e0.z), -sin(_Rotation7031e04a7ad344669638bbee6d28c5e0.z), sin(_Rotation7031e04a7ad344669638bbee6d28c5e0.z), cos(_Rotation7031e04a7ad344669638bbee6d28c5e0.z)));

float distance7031e04a7ad344669638bbee6d28c5e0 = SDF_Cube_05845aac9d55425c8e1f8d191d017e1e(position7031e04a7ad344669638bbee6d28c5e0, _Scale7031e04a7ad344669638bbee6d28c5e0);

if (distance7031e04a7ad344669638bbee6d28c5e0 < resultDistance)
{
resultDistance = distance7031e04a7ad344669638bbee6d28c5e0;
resultColour = _Colour7031e04a7ad344669638bbee6d28c5e0.xyz;
}

float3 position57c95a0f6ffa4354bf7f8f17f47c3610 = origin - _Position57c95a0f6ffa4354bf7f8f17f47c3610;

position57c95a0f6ffa4354bf7f8f17f47c3610.xz = mul(position57c95a0f6ffa4354bf7f8f17f47c3610.xz, float2x2(cos(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.y), sin(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.y), -sin(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.y), cos(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.y)));
position57c95a0f6ffa4354bf7f8f17f47c3610.yz = mul(position57c95a0f6ffa4354bf7f8f17f47c3610.yz, float2x2(cos(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.x), -sin(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.x), sin(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.x), cos(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.x)));
position57c95a0f6ffa4354bf7f8f17f47c3610.xy = mul(position57c95a0f6ffa4354bf7f8f17f47c3610.xy, float2x2(cos(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.z), -sin(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.z), sin(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.z), cos(_Rotation57c95a0f6ffa4354bf7f8f17f47c3610.z)));

float distance57c95a0f6ffa4354bf7f8f17f47c3610 = SDF_Cube_05845aac9d55425c8e1f8d191d017e1e(position57c95a0f6ffa4354bf7f8f17f47c3610, _Scale57c95a0f6ffa4354bf7f8f17f47c3610);

if (distance57c95a0f6ffa4354bf7f8f17f47c3610 < resultDistance)
{
resultDistance = distance57c95a0f6ffa4354bf7f8f17f47c3610;
resultColour = _Colour57c95a0f6ffa4354bf7f8f17f47c3610.xyz;
}


            return float4(resultColour.xyz, resultDistance);
        }

        float3 GetLight(float3 pos, float3 normal)
        {
            float3 light = float3(0, 0, 0);
            
            light += float3(1, 0.9568627, 0.8392157) * max(0.0, dot(-normal, float3(-0.3213938, -0.7660444, 0.5566705))) * 1; 


            return light;
        }

        float3 GetObjectNormal(float3 pos)
        {
            float2 offset = float2(0.01f, 0.0f);
            float3 normal = float3(
                GetDistanceFromObjects(pos + offset.xyy).w - GetDistanceFromObjects(pos - offset.xyy).w,
                GetDistanceFromObjects(pos + offset.yxy).w - GetDistanceFromObjects(pos - offset.yxy).w,
                GetDistanceFromObjects(pos + offset.yyx).w - GetDistanceFromObjects(pos - offset.yyx).w
            );

            return normalize(normal);
        }

        float3 CalculateLighting(Ray ray, float3 colour, float distance)
        {
            // Object Shading
            float3 pos = ray.Origin + ray.Direction * distance;
            float3 normal = GetObjectNormal(pos);

            // Adding Light
            float3 combinedColour = colour * _AmbientColour;
            combinedColour += GetLight(pos, normal) * colour;

            return combinedColour;
        }

        half4 Raymarch(Ray ray, float depth)
        {
            float relaxOmega = _Relaxation;
            float distanceTraveled = _ProjectionParams.y; // near clip plane
            float candidateError = _RenderDistance;
            float candidateDistanceTraveled = distanceTraveled;
            float3 candidateColour = float3(0, 0, 0);
            float prevRadius = 0;
            float stepLength = 0;

            float funcSign = GetDistanceFromObjects(ray.Origin).w < 0 ? +1 : +1;

            [loop]
            for (int i = 0; i < _MaxIterations; i++)
            {
                float3 pos = ray.Origin + ray.Direction * distanceTraveled;
                float4 combined = GetDistanceFromObjects(pos);
                float3 colour = combined.xyz;
                float distance = combined.w;

                float signedRadius = funcSign * distance;
                float radius = abs(signedRadius);

                bool sorFail = relaxOmega > 1 && (radius + prevRadius) < stepLength;

                [branch]
                if (sorFail)
                {
                    stepLength -= relaxOmega * stepLength;
                    relaxOmega = 1;
                }
                else
                {
                    stepLength = signedRadius * relaxOmega;
                }

                prevRadius = radius;

                [branch]
                if (sorFail)
                {
                    distanceTraveled += stepLength;
                    continue;
                }

                if (distanceTraveled > _RenderDistance || distanceTraveled >= depth) // Environment
                {
                    return half4(ray.Direction, 0);
                }

                float error = radius / distanceTraveled;

                if (error < candidateError)
                {
                    candidateDistanceTraveled = distanceTraveled;
                    candidateColour = colour;
                    candidateError = error;

                    if (error < _HitResolution) break; // Hit Something
                }

                distanceTraveled += stepLength;
            }

            return half4(CalculateLighting(ray, candidateColour, candidateDistanceTraveled), 1);
        }
        ENDHLSL

        Pass
        {
            HLSLPROGRAM
            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f vert(appdata v)
            {
                #ifdef UNITY_UV_STARTS_AT_TOP
                // v.uv.y = 1 - v.uv.y;
                #endif

                v2f o;
                o.vertex = TransformObjectToHClip(v.vertex.xyz);
                o.uv = UnityStereoTransformScreenSpaceTex(v.uv);
                return o;
            }

            half4 frag(v2f i) : SV_Target0
            {
                Ray ray = CreateCameraRay(i.uv, _CamToWorldMatrix);

                #if UNITY_REVERSED_Z
                float depth = SampleSceneDepth(i.uv);
                #else
                // Adjust z to match NDC for OpenGL
                float depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(i.uv));
                #endif

                depth = LinearEyeDepth(depth, _ZBufferParams) * ray.Length;

                half4 result = Raymarch(ray, depth);
                return half4(tex2D(_MainTex, i.uv).xyz * (1.0 - result.w) + result.xyz * result.w, 1.0);
            }
            ENDHLSL
        }
    }
}