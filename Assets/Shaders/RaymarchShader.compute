#pragma kernel CSMain

#include "UnityCG.cginc"
#include "RaymarchObjectInfo.cginc"
#include "Ray.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> _Source;
RWTexture2D<float4> _Destination;

// Camera
Texture2D<float4> _CamDepthTexture;
float4x4 _CamInverseProjection;
float4x4 _CamToWorld;
float _RenderDistance;

// Lighting
float3 _LightDirection;

// Raymarch Object Info
StructuredBuffer<RaymarchObjectInfo> _ObjectInfo;
int _ObjectInfoCount;


float sdf_Sphere(float3 origin, RaymarchObjectInfo object)
{
    return length(origin - object.Position) - object.Scale.x;
}

float PerformSDF(float3 origin, RaymarchObjectInfo object)
{
    return sdf_Sphere(origin, object);
}

float4 PerformOperation(float globalDistance, float3 globalColour, float objectDistance, RaymarchObjectInfo object)
{
    float distance = globalDistance;
    float3 colour = globalColour;

    switch (object.Operation)
    {
    case 1: // blend
        {
            // https://www.iquilezles.org/www/articles/smin/smin.htm
            const float h = clamp(0.5 + 0.5 * (objectDistance - distance) / object.OperationMod, 0.0, 1.0);
            distance = lerp(objectDistance, distance, h) - object.OperationMod * h * (1.0 - h);
            colour = lerp(object.Colour.xyz, colour, h);
            break;
        }
    case 2: // cut
        {
            if (-objectDistance > distance)
            {
                distance = -objectDistance;
                colour = object.Colour.xyz;
            }
            break;
        }
    case 3: // mask
        {
            if (objectDistance > distance)
            {
                distance = objectDistance;
                colour = object.Colour.xyz;
            }
            break;
        }
    default:
        {
            if (objectDistance < distance)
            {
                distance = objectDistance;
                colour = object.Colour.xyz;
            }
            break;
        }
    }


    return float4(colour.xyz, distance);
}

float4 distanceField(float3 origin)
{
    float distance = _RenderDistance;
    float3 colour = float3(1, 1, 1);

    for (int i = 0; i < _ObjectInfoCount; i++)
    {
        const float objectDistance = PerformSDF(origin, _ObjectInfo[i]);
        const float4 operation = PerformOperation(distance, colour, objectDistance, _ObjectInfo[i]);
        
        distance = operation.w;
        colour = operation.xyz;
    }

    return float4(colour.xyz, distance);
}

float3 getNormal(float3 pos)
{
    const float2 offset = float2(0.01f, 0.0f);
    const float3 normal = float3(
        distanceField(pos + offset.xyy).w - distanceField(pos - offset.xyy).w,
        distanceField(pos + offset.yxy).w - distanceField(pos - offset.yxy).w,
        distanceField(pos + offset.yyx).w - distanceField(pos - offset.yyx).w
    );

    return normalize(normal);
}

fixed4 raymarching(Ray ray, float depth)
{
    fixed4 result = fixed4(1, 1, 1, 1);

    const int maxIter = 164;
    float distanceTraveled = 0;

    for (int i = 0; i < maxIter; i++)
    {
        if (distanceTraveled > _RenderDistance || distanceTraveled >= depth)
        {
            // Environment
            result = fixed4(ray.Direction, 0);
            break;
        }

        const float3 pos = ray.Origin + ray.Direction * distanceTraveled;
        // Check for hit in distance field
        const float4 combined = distanceField(pos);
        const float3 colour = combined.xyz;
        const float distance = combined.w;

        if (distance < 0.01) // Hit something
        {
            // Object Shading
            const float3 normal = getNormal(pos);
            const float light = dot(-_LightDirection, normal);

            result = fixed4(colour * light, 1);
            break;
        }

        distanceTraveled += distance;
    }

    return result;
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    _Destination.GetDimensions(width, height);
    const float2 uv = id.xy / float2(width, height) * 2 - 1;

    Ray ray = CreateCameraRay(uv, _CamToWorld, _CamInverseProjection);
    float depth = LinearEyeDepth(_CamDepthTexture[id.xy].r);
    depth *= length(ray.Direction);

    ray.Direction = normalize(ray.Direction);

    fixed4 result = raymarching(ray, depth);
    _Destination[id.xy] = fixed4(_Source[id.xy] * (1.0 - result.w) + result.xyz * result.w, 1.0);
}
